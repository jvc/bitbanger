#!/usr/bin/env python
'''

bitbanger OPTIONS MASK
bitbanger OPTIONS POS [POS]...

POS is a bit position, MASK is a bitmask specified as an integer in
the byte order of this host. 0x may be used to indicate hex.

Example:
> bb 1 2 3 4
> bb 0x1e

'''

__version__ = "0.1"
__date__ = "2010-02-07"
__author__ = "Justin Chouinard <jvc@jvic.net>"
__copyright__ = "Copyright 2010, Justin Chouinard"
__license__ = "MIT"

import sys

BYTE_ORDER_MSG="The byte order of this host is %s endian." % (sys.byteorder)

def get_bit_list(byte_list = None, mask = 0):
    '''Return a list() of int()s set to 0 or 1.
    '''
    bits = []
    if byte_list:
        for byte in byte_list:
            for offset in range(8):
                bits.append((1 << int(offset)) & int(byte))
    elif mask:
        for bit in range(word_size):
            bits.append((1 << int(bit)) & int(mask))

    return bits

def get_byte_list(mask, word_size):
    '''Return a list() of bytes.
    '''
    bytes = []
    for byte in range(word_size / 8):
        val = 0xff & (int(mask) >> (8 * byte))
        bytes.append(val)

    return bytes

def print_bit_list(bit_list):
    '''Print a list() of bits. Traverse backwards so it reads properly
    with the high bit on the LHS.
    '''
    print "Bin: ",
    pos = len(bit_list) - 1
    while pos > -1:
        bit = 1 if bit_list[pos] else 0
        print bit,
        if pos % 8 == 0:
            print ' ',
        pos -= 1
    print
        
    print "Set: ",
    setbits = []
    pos = 0
    for item in bit_list:
        if item:
            setbits.append(str(pos))
        pos += 1
    print ' '.join(setbits)

def print_byte_list(byte_list):
    '''Print a list() of bytes. Traverse backwards so it reads properly
    with the high bit on the LHS.
    '''
    index = len(byte_list) - 1
    while index > -1:
        print "%02x" % byte_list[index],
        index -= 1
    print


def main(mask, options):
    print "      mask: 0x%08x ->" % mask,
    byte_list = get_byte_list(mask, options.word_size)
    bit_list = get_bit_list(byte_list=byte_list)
    print_byte_list(byte_list)
    print_bit_list(bit_list)

    def to_hex_str(input):
        return "%02x" % input

    print "  reversed: 0x%s ->" % ''.join(map(to_hex_str, byte_list)),
    byte_list.reverse()
    print_byte_list(byte_list)

    
if __name__ == '__main__':
    from optparse import OptionParser

    parser = OptionParser(usage=__doc__ + BYTE_ORDER_MSG)
    parser.add_option("-s", "--size", dest="word_size", type="int", default=32,
                      help="Set word size to SIZE bits", metavar="SIZE")
    (options, args) = parser.parse_args()

    mask = 0
    if len(args) > 1:
        # user passed in enabled bits, build generic mask
        for arg in args:
            mask |= (1 << (int(arg)))
    else:
        if len(args) > 0:
            # user passed in a mask, native for this host. the use
            # eval() instead of hex() will require 0x to be specified
            # on the command line, but it allows the mask to be
            # specified in decimal or octal.
            mask = eval(args[0])
        else:
            parser.print_help()
            exit(1)
    
    main(mask, options)
